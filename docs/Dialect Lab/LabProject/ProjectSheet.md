# Lab Project: ML Shape Computation Optimizer Pass

## é¡¹ç›®æ¦‚è¿°

åœ¨æœºå™¨å­¦ä¹ ç¼–è¯‘å™¨ä¸­ï¼Œå¤§é‡çš„è®¡ç®—æ¶‰åŠå¼ é‡å½¢çŠ¶çš„æ¨å¯¼å’Œç®—æœ¯è¿ç®—ã€‚è®¸å¤šè¿™äº›è®¡ç®—åœ¨ç¼–è¯‘æ—¶å°±èƒ½ç¡®å®šï¼Œé€šè¿‡å¸¸é‡æŠ˜å å’Œå½¢çŠ¶æ¨å¯¼å¯ä»¥æ˜¾è‘—æå‡è¿è¡Œæ—¶æ€§èƒ½ã€‚æœ¬é¡¹ç›®è¦æ±‚ä½ å®ç°ä¸€ä¸ªMLIR Passæ¥ä¼˜åŒ–è¿™ç±»è®¡ç®—ã€‚

## å­¦ä¹ ç›®æ ‡

é€šè¿‡å®Œæˆæœ¬é¡¹ç›®ï¼Œä½ å°†ï¼š
- æŒæ¡MLIR Passçš„å®Œæ•´å¼€å‘æµç¨‹
- ç†è§£å¸¸é‡æŠ˜å å’Œå½¢çŠ¶æ¨å¯¼çš„ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€æœ¯
- åº”ç”¨æ‰€æœ‰è¯¾ç¨‹ä¸­å­¦åˆ°çš„MLIR DialectçŸ¥è¯†
- å­¦ä¼šæµ‹è¯•é©±åŠ¨çš„ç¼–è¯‘å™¨å¼€å‘æ–¹æ³•
- ä¸ºTPU_MLIRç­‰çœŸå®é¡¹ç›®æ‰“ä¸‹åŸºç¡€

## é¡¹ç›®èƒŒæ™¯

### é—®é¢˜åœºæ™¯
åœ¨ç¥ç»ç½‘ç»œç¼–è¯‘ä¸­ï¼Œç»å¸¸é‡åˆ°å¦‚ä¸‹ä»£ç æ¨¡å¼ï¼š

```mlir
// å·ç§¯å±‚è¾“å‡ºå½¢çŠ¶è®¡ç®—
%input_h = arith.constant 224 : index
%kernel = arith.constant 3 : index
%stride = arith.constant 2 : index
%output_h = arith.divsi %input_h, %stride : index  // å¯ä»¥ç¼–è¯‘æ—¶è®¡ç®—

// åŠ¨æ€å¼ é‡åˆ›å»º
%size = arith.muli %dim1, %dim2 : index  // å¸¸é‡ç›¸ä¹˜
%tensor = tensor.empty(%size) : tensor<?xf32>  // å¯ä»¥å˜ä¸ºé™æ€å½¢çŠ¶
```

è¿™äº›è®¡ç®—å®Œå…¨å¯ä»¥åœ¨ç¼–è¯‘æ—¶å®Œæˆï¼Œé¿å…è¿è¡Œæ—¶å¼€é”€ã€‚

### ä¼˜åŒ–ç›®æ ‡
ä½ çš„Passéœ€è¦å°†ä¸Šè¿°ä»£ç ä¼˜åŒ–ä¸ºï¼š

```mlir
%output_h = arith.constant 112 : index  // ç›´æ¥è®¡ç®—ç»“æœ
%tensor = tensor.empty() : tensor<200xf32>  // é™æ€å½¢çŠ¶
```

## æŠ€æœ¯è¦æ±‚

### å¿…é¡»å®ç°çš„ä¼˜åŒ–
1. **ç®—æœ¯å¸¸é‡æŠ˜å ** (arith dialect)
   - åŠ æ³•ã€å‡æ³•ã€ä¹˜æ³•ã€é™¤æ³•çš„å¸¸é‡æ“ä½œ
   - æ¯”è¾ƒæ“ä½œçš„å¸¸é‡æ¡ä»¶

2. **å¼ é‡å½¢çŠ¶æ¨å¯¼** (tensor dialect)  
   - `tensor.empty` çš„é™æ€å½¢çŠ¶è½¬æ¢
   - åŠ¨æ€ç»´åº¦åˆ°é™æ€ç»´åº¦çš„æ¨å¯¼

3. **æ§åˆ¶æµç®€åŒ–** (scf dialect)
   - å¸¸é‡æ¡ä»¶çš„ `scf.if` åˆ†æ”¯é€‰æ‹©
   - æ­»ä»£ç æ¶ˆé™¤

4. **å‡½æ•°ä¼˜åŒ–** (builtin dialect)
   - ç®€å•çš„å¸¸é‡ä¼ æ’­

### çŸ¥è¯†ç‚¹è¦†ç›–

| è¯¾ç¨‹Lab | åœ¨é¡¹ç›®ä¸­çš„åº”ç”¨ | å…·ä½“æŠ€æœ¯ |
|---------|---------------|----------|
| Lab 1-2 | PassåŸºç¡€æ¶æ„ | PassWrapper, æ“ä½œéå† |
| Lab 4 | Builtinæ“ä½œ | æ¨¡å—éå†, å‡½æ•°å¤„ç† |
| Lab 5 | Arithä¼˜åŒ– | å¸¸é‡æŠ˜å , ç®—æœ¯ç®€åŒ– |
| Lab 6 | SCFç®€åŒ– | æ¡ä»¶åˆ†æ”¯ä¼˜åŒ– |
| Lab 7 | Memoryç›¸å…³ | é™æ€å¤§å°ä¼˜åŒ–å»ºè®® |
| Lab 8 | Tensoræ“ä½œ | å½¢çŠ¶æ¨å¯¼, é™æ€åŒ– |
| Lab 9 | Linalgæ“ä½œ | ç‰¹æ®ŠçŸ©é˜µæ“ä½œè¯†åˆ« |
| Lab 10 | Passç³»ç»Ÿ | RewritePattern |

## é¡¹ç›®ç»“æ„

```
shape-optimizer-project/
â”œâ”€â”€ test-cases/
â”‚   â”œâ”€â”€ input/           # ä¼˜åŒ–å‰çš„æµ‹è¯•ç”¨ä¾‹
â”‚   â”œâ”€â”€ expected/        # æœŸæœ›çš„ä¼˜åŒ–ç»“æœ
â”‚   â””â”€â”€ run-tests.sh     # è‡ªåŠ¨åŒ–æµ‹è¯•è„šæœ¬
â”œâ”€â”€ framework/
â”‚   â”œâ”€â”€ CMakeLists.txt   # æ„å»ºé…ç½®
â”‚   â”œâ”€â”€ main.cpp         # å·¥å…·ä¸»ç¨‹åº
â”‚   â””â”€â”€ PassSkeleton.cpp # Passå®ç°éª¨æ¶
â”œâ”€â”€ README.md            # é¡¹ç›®è¯´æ˜
â””â”€â”€ æœ¬æ–‡æ¡£.md            # è¯¦ç»†æŒ‡å¯¼
```

## å¼€å‘æ­¥éª¤

### Phase 1: ç¯å¢ƒæ­å»º
1. ç¼–è¯‘æä¾›çš„æ¡†æ¶ä»£ç 
2. è¿è¡Œæµ‹è¯•è„šæœ¬ï¼ŒæŸ¥çœ‹åˆå§‹çŠ¶æ€
3. ç†è§£Passçš„åŸºæœ¬ç»“æ„

### Phase 2: ç®—æœ¯æŠ˜å 
1. å®ç° `arith.addi`, `arith.subi`, `arith.muli`, `arith.divsi` çš„å¸¸é‡æŠ˜å 
2. é€šè¿‡ `conv_shape.mlir` å’Œ `matrix_chain.mlir` æµ‹è¯•
3. ç¡®ä¿åŸºæœ¬çš„ç®—æœ¯ä¼˜åŒ–å·¥ä½œæ­£å¸¸

### Phase 3: å½¢çŠ¶æ¨å¯¼
1. å®ç° `tensor.empty` çš„é™æ€å½¢çŠ¶è½¬æ¢
2. å¤„ç†å¸¸é‡ç»´åº¦å‚æ•°
3. é€šè¿‡ `dynamic_shape.mlir` æµ‹è¯•

### Phase 4: æ§åˆ¶æµä¼˜åŒ–
1. å®ç° `scf.if` çš„å¸¸é‡æ¡ä»¶ä¼˜åŒ–
2. å¤„ç†åˆ†æ”¯é€‰æ‹©å’Œæ­»ä»£ç æ¶ˆé™¤
3. é€šè¿‡ `conditional_shape.mlir` æµ‹è¯•

### Phase 5: é›†æˆæµ‹è¯•
1. è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶
2. ä¿®å¤å‘ç°çš„é—®é¢˜
3. ä¼˜åŒ–ä»£ç è´¨é‡

## æµ‹è¯•ç”¨ä¾‹è¯´æ˜

### Test Case 1: conv_shape.mlir
**ç›®æ ‡**: å·ç§¯å±‚è¾“å‡ºå½¢çŠ¶çš„ç¼–è¯‘æ—¶è®¡ç®—
**æ¶‰åŠ**: arith dialectçš„å¤æ‚ç®—æœ¯è¡¨è¾¾å¼
**éš¾åº¦**: â­â­

### Test Case 2: dynamic_shape.mlir  
**ç›®æ ‡**: åŠ¨æ€å¼ é‡å½¢çŠ¶çš„é™æ€åŒ–
**æ¶‰åŠ**: tensor dialect + arithå¸¸é‡ä¼ æ’­
**éš¾åº¦**: â­â­â­

### Test Case 3: conditional_shape.mlir
**ç›®æ ‡**: æ¡ä»¶åˆ†æ”¯ä¸­çš„å½¢çŠ¶é€‰æ‹©ä¼˜åŒ–
**æ¶‰åŠ**: scf dialect + è·¨å‡½æ•°ä¼˜åŒ–
**éš¾åº¦**: â­â­â­â­

### Test Case 4: matrix_chain.mlir
**ç›®æ ‡**: çŸ©é˜µæ“ä½œé“¾çš„å½¢çŠ¶å’Œåˆå§‹åŒ–ä¼˜åŒ–
**æ¶‰åŠ**: linalg dialect + ç»¼åˆä¼˜åŒ–
**éš¾åº¦**: â­â­

## å®ç°æç¤º

### æ ¸å¿ƒç®—æ³•æ€è·¯
```cpp
void runOnOperation() override {
  // 1. æ”¶é›†æ‰€æœ‰å¸¸é‡å®šä¹‰
  DenseMap<Value, APInt> constantValues;
  collectConstants(constantValues);
  
  // 2. éå†æ‰€æœ‰ç®—æœ¯æ“ä½œï¼Œå°è¯•æŠ˜å 
  walkArithmeticOps(constantValues);
  
  // 3. æ¨å¯¼å¼ é‡çš„é™æ€å½¢çŠ¶
  propagateStaticShapes(constantValues);
  
  // 4. ç®€åŒ–æ§åˆ¶æµ
  simplifyControlFlow(constantValues);
  
  // 5. æ¸…ç†æ­»ä»£ç 
  eliminateDeadCode();
}
```

### å…³é”®æŠ€æœ¯ç‚¹
1. **å¸¸é‡è¯†åˆ«**: ä½¿ç”¨ `dyn_cast<arith::ConstantOp>()` è¯†åˆ«å¸¸é‡
2. **å€¼æ›¿æ¢**: ä½¿ç”¨ `Value::replaceAllUsesWith()` æ›´æ–°ä½¿ç”¨å…³ç³»
3. **æ“ä½œåˆ é™¤**: ä½¿ç”¨ `Operation::erase()` åˆ é™¤æ— ç”¨æ“ä½œ
4. **ç±»å‹æ„é€ **: ä½¿ç”¨ `RankedTensorType::get()` åˆ›å»ºé™æ€å½¢çŠ¶ç±»å‹

### å¸¸è§é™·é˜±
- ä¸è¦åœ¨éå†è¿‡ç¨‹ä¸­ç›´æ¥ä¿®æ”¹IRï¼Œå…ˆæ”¶é›†å†æ‰¹é‡å¤„ç†
- æ³¨æ„æ“ä½œçš„ä½¿ç”¨è®¡æ•°ï¼Œé¿å…åˆ é™¤ä»è¢«ä½¿ç”¨çš„æ“ä½œ
- ç¡®ä¿ç±»å‹å…¼å®¹æ€§ï¼Œé™æ€å½¢çŠ¶è½¬æ¢è¦ä¿æŒå…ƒç´ ç±»å‹ä¸å˜

## æäº¤è¦æ±‚

### å¿…éœ€æ–‡ä»¶
- ä¿®æ”¹åçš„ `PassSkeleton.cpp` (é‡å‘½åä¸ºä½ çš„å®ç°)
- ä¿®æ”¹åçš„ `CMakeLists.txt` (å¦‚æœ‰éœ€è¦)
- æµ‹è¯•è¿è¡ŒæŠ¥å‘Š (test_results.txt)
- é¡¹ç›®æ€»ç»“æ–‡æ¡£ (summary.md)

### å¯é€‰æ–‡ä»¶
- é¢å¤–çš„æµ‹è¯•ç”¨ä¾‹
- æ€§èƒ½åˆ†ææŠ¥å‘Š

## å‚è€ƒèµ„æº

- [MLIR Pass Infrastructure](https://mlir.llvm.org/docs/PassManagement/)
- [MLIR Operation Definition](https://mlir.llvm.org/docs/LangRef/#operations)
- [Constant Folding in Compilers](https://en.wikipedia.org/wiki/Constant_folding)
- è¯¾ç¨‹ä¸­çš„æ‰€æœ‰Labå®éªŒä»£ç 

## æŠ€æœ¯æ”¯æŒ

å¦‚é‡åˆ°é—®é¢˜ï¼Œå¯ä»¥å‚è€ƒï¼š
1. è¿è¡Œ `./shape-opt --help` æŸ¥çœ‹å·¥å…·ä½¿ç”¨æ–¹æ³•
2. ä½¿ç”¨ `mlir-opt --verify-diagnostics` éªŒè¯MLIRè¯­æ³•
3. å‚è€ƒè¯¾ç¨‹Labä¸­çš„ç±»ä¼¼å®ç°æ¨¡å¼
4. æŸ¥çœ‹MLIRå®˜æ–¹æ–‡æ¡£å’Œç¤ºä¾‹ä»£ç 

ç¥ä½ ç¼–ç¨‹æ„‰å¿«ï¼ğŸš€